트리 (Tree) 구조
    트리: Node와 Branch를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조
        트리 중 이진 트리 (Binary Tree) 형태의 구조로, 탐색(검색) 알고리즘 구현을 위해 많이 사용됨

        Node: 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)
        Root Node: 트리 맨 위에 있는 노드
        Level: 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄
        Parent Node: 어떤 노드의 다음 레벨에 연결된 노드
        Child Node: 어떤 노드의 상위 레벨에 연결된 노드
        Leaf Node (Terminal Node): Child Node가 하나도 없는 노드
        Sibling (Brother Node): 동일한 Parent Node를 가진 노드
   
    3. 이진 트리와 이진 탐색 트리 (Binary Search Tree)
        이진 트리: 노드의 최대 Branch가 2인 트리
        이진 탐색 트리 (Binary Search Tree, BST): 이진 트리에 다음과 같은 추가적인 조건이 있는 트리

        왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드는 해당 노드보다 큰 값

    4. 자료 구조 이진 탐색 트리의 장점과 주요 용도
        주요 용도: 데이터 검색(탐색)
        장점: 탐색 속도를 개선할 수 있음





힙 (Heap)
    힙: 데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리(Complete Binary Tree)
        (완전 이진 트리: 노드를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리)
    힙을 사용하는 이유

    우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용

    힙 (Heap) 구조
        힙은 최대값을 구하기 위한 구조 (최대 힙, Max Heap) 와, 최소값을 구하기 위한 구조 (최소 힙, Min Heap) 로 분류할 수 있음
    힙 조건
        각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 같다. (최대 힙의 경우)
        최소 힙의 경우는 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 작다
    
        완전 이진 트리 형태를 가짐
    
    힙과 이진 탐색 트리의 공통점과 차이점
        공통점: 힙과 이진 탐색 트리는 모두 이진 트리임
        차이점:
            힙은 각 노드의 값이 자식 노드보다 크거나 같음(Max Heap의 경우)
            이진 탐색 트리는 왼쪽 자식 노드의 값이 가장 작고, 그 다음 부모 노드, 그 다음 오른쪽 자식 노드 값이 가장 큼
            힙은 이진 탐색 트리의 조건인 자식 노드에서 작은 값은 왼쪽, 큰 값은 오른쪽이라는 조건은 없음
            힙의 왼쪽 및 오른쪽 자식 노드의 값은 오른쪽이 클 수도 있고, 왼쪽이 클 수도 있음
            이진 탐색 트리는 탐색을 위한 구조, 힙은 최대/최소값 검색을 위한 구조 중 하나로 이해하면 됨

    힙에 데이터 삽입하기 - 기본 동작
        힙은 완전 이진 트리이므로, 삽입할 노드는 기본적으로 왼쪽 최하단부 노드부터 채워지는 형태로 삽입 

    삽입할 데이터가 힙의 데이터보다 클 경우 (Max Heap)
        먼저 삽입된 데이터는 완전 이진 트리 구조에 맞추어, 최하단부 왼쪽 노드부터 채워짐
        채워진 노드 위치에서, 부모 노드보다 값이 클 경우, 부모 노드와 위치를 바꿔주는 작업을 반복함 (swap)

    힙과 배열
        힙 구현시 배열 활용
        배열은 인덱스가 0번부터 시작하지만, 힙 구현의 편의를 위해, root 노드 인덱스 번호를 1로 지정하면, 구현이 좀더 수월함
        부모 노드 인덱스 번호 (parent node's index) = 자식 노드 인덱스 번호 (child node's index) // 2
        왼쪽 자식 노드 인덱스 번호 (left child node's index) = 부모 노드 인덱스 번호 (parent node's index) * 2
        오른쪽 자식 노드 인덱스 번호 (right child node's index) = 부모 노드 인덱스 번호 (parent node's index) * 2 + 1 